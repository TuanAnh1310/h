<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic Christmas - Circular Gallery</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=Quicksand:wght@400;600&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

    <style>
        /* --- CORE STYLES & AURORA BG --- */
        body { 
            margin: 0; overflow: hidden; 
            background: linear-gradient(45deg, #0f0c29, #302b63, #24243e);
            background-size: 400% 400%;
            animation: aurora 15s ease infinite;
            font-family: 'Quicksand', sans-serif;
        }
        @keyframes aurora {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        #canvas-container { width: 100%; height: 100vh; display: block; }
        
        /* --- UI LAYER --- */
        #ui-layer {
            position: absolute; bottom: 30px; width: 100%;
            text-align: center; pointer-events: none; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        
        .guide-box {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
            padding: 15px 30px; border-radius: 20px;
            border: 1px solid rgba(255, 215, 0, 0.4);
            color: #fff; 
            font-family: 'Playfair Display', serif;
            font-size: 16px; margin-bottom: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
            display: flex; gap: 20px; flex-wrap: wrap; justify-content: center;
            max-width: 85%;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        .guide-box span { 
            display: flex; align-items: center; gap: 8px;
            padding: 5px 10px; border-radius: 10px;
            background: rgba(0,0,0,0.2);
            transition: transform 0.2s;
        }
        .guide-box span:hover { transform: scale(1.05); background: rgba(255, 215, 0, 0.2); }
        .guide-box b { color: #FFD700; font-weight: 700; letter-spacing: 0.5px; }

        #message-box {
            font-family: 'Playfair Display', serif;
            font-size: 20px; color: #FFD700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
            min-height: 30px; margin-bottom: 15px;
            font-style: italic; letter-spacing: 0.5px;
        }
        #cursor { animation: blink 1s infinite; border-right: 2px solid #fff;}
        @keyframes blink { 50% { opacity: 0; } }

        button#btnStart {
            pointer-events: auto; cursor: pointer;
            background: linear-gradient(90deg, #FFD700, #DAA520);
            color: #1a0a2e; border: none;
            padding: 14px 40px; border-radius: 50px; 
            font-family: 'Quicksand', sans-serif; font-weight: 700; font-size: 18px; 
            text-transform: uppercase; letter-spacing: 1px;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.6);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        button#btnStart:hover { 
            transform: scale(1.1); 
            box-shadow: 0 0 40px rgba(255, 215, 0, 1); 
            background: #fff;
        }

        #btnCamToggle {
            position: absolute; top: 20px; left: 20px; width: 50px; height: 50px;
            background: rgba(0, 0, 0, 0.4); backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.2); border-radius: 50%;
            color: #FFF; font-size: 20px; cursor: pointer; z-index: 200;
            display: none; box-shadow: 0 0 15px rgba(0,0,0,0.5);
            transition: all 0.3s;
        }
        #btnCamToggle:hover { background: rgba(255,215,0,0.2); transform: rotate(90deg); }

        #camera-wrapper {
            position: absolute; top: 20px; right: 20px; width: 140px; height: 105px; 
            z-index: 50; pointer-events: none; transition: all 0.3s ease;
            filter: drop-shadow(0 0 10px rgba(0,0,0,0.5));
        }
        #camera-preview {
            width: 100%; height: 100%; border: 2px solid rgba(255, 215, 0, 0.5);
            transform: scaleX(-1); opacity: 0.9; border-radius: 15px;
        }
        
        #copyright { position: absolute; bottom: 10px; right: 15px; color: rgba(255,255,255,0.2); font-size: 11px; z-index: 99; pointer-events: none;}
        
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #FFD700; font-size: 24px; pointer-events: none; display: none; 
            font-family: 'Playfair Display', serif; text-shadow: 0 0 20px rgba(255, 100, 0, 0.8);
            z-index: 200; text-align: center; width: 100%;
            animation: pulse 1.5s infinite ease-in-out;
        }
        @keyframes pulse { 0%,100%{opacity:0.6;} 50%{opacity:1;} }

        @media (max-width: 768px) {
            #camera-wrapper { width: 100px; height: 75px; top: 10px; right: 10px; }
            .guide-box { font-size: 14px; padding: 10px 15px; width: 90%; gap: 10px; }
            button#btnStart { padding: 12px 25px; font-size: 16px; }
        }
    </style>
</head>
<body>
    
    <button id="btnCamToggle" title="B·∫≠t/T·∫Øt Camera"><i class="fas fa-video"></i></button>

    <div id="ui-layer">
        <div class="guide-box" id="guideText">
             <span>‚úä <b>N·∫Øm tay:</b> C√¢y Th√¥ng</span>
             <span>üñê <b>X√≤e tay:</b> Ph√°o Hoa</span>
             <span>‚úåÔ∏è <b>Hi:</b> Xem ·∫¢nh</span>
             <span>ü´∞ <b>B·∫Øn Tim:</b> Tr√°i Tim</span>
        </div>
        <div id="message-box"></div>
        <button id="btnStart"> B·∫Øt ƒë·∫ßu ph√©p thu·∫≠t ‚ú® </button>
    </div>

    <div id="copyright">¬© designed by S1mple</div>
    
    <div id="loading">ƒêang t·∫£i ph√©p thu·∫≠t...<br>(B·∫≠t camera l√™n nh√© ‚ù§Ô∏è)</div>

    <div id="canvas-container"></div>
    
    <div id="camera-wrapper">
        <canvas id="camera-preview"></canvas>
    </div>
    <video class="input_video" style="display:none"></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            goldCount: 3500, redCount: 1200, 
            snowCount: 2500, heartRainCount: 500, 
            explodeRadius: 300, treeHeight: 90, treeBaseRadius: 45
        };
        const MUSIC_URL = "./imissyou.mp3"; 
        const typingText = "Gi√°ng sinh ·∫•m √°p v√† h·∫°nh ph√∫c nh√©! ‚ù§Ô∏è Mong ƒëi·ªÅu k·ª≥ di·ªáu s·∫Ω ƒë·∫øn v·ªõi c·∫≠u...";

        const photoFiles = ['image_1.png', 'image_2.png', 'image_3.png', 'image_4.png', 'image_5.png'];
        const loader = new THREE.TextureLoader();
        const photoTextures = [];

        // --- TEXTURES & ALPHA MAPS ---
        function createSharpGlow(colorCore, colorOuter) {
            const cvs=document.createElement('canvas'); cvs.width=128; cvs.height=128; const ctx=cvs.getContext('2d');
            const grd=ctx.createRadialGradient(64,64,4,64,64,50);
            grd.addColorStop(0,'#FFFFFF'); grd.addColorStop(0.1,colorCore); grd.addColorStop(0.5,colorOuter); grd.addColorStop(1,'transparent');
            ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(64,64,64,0,Math.PI*2); ctx.fill(); return new THREE.CanvasTexture(cvs);
        }
        function createSoftSnowTex() {
            const cvs=document.createElement('canvas'); cvs.width=64; cvs.height=64; const ctx=cvs.getContext('2d');
            const grd=ctx.createRadialGradient(32,32,2,32,32,28);
            grd.addColorStop(0,'rgba(255,255,255,1)'); grd.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(32,32,32,0,Math.PI*2); ctx.fill(); return new THREE.CanvasTexture(cvs);
        }
        function createHeartTex() {
            const cvs=document.createElement('canvas'); cvs.width=128; cvs.height=128; const ctx=cvs.getContext('2d');
            ctx.fillStyle="#FF0044"; ctx.shadowColor="#FF5577"; ctx.shadowBlur=15; 
            ctx.translate(64,64); ctx.scale(3,3);
            const d="M0 -10 C -10 -25 -25 -10 -10 5 L 0 15 L 10 5 C 25 -10 10 -25 0 -10 Z"; ctx.fill(new Path2D(d));
            return new THREE.CanvasTexture(cvs);
        }
        // NEW: T·∫°o Alpha Map h√¨nh tr√≤n ƒë·ªÉ c·∫Øt ·∫£nh
        function createCircularAlphaMap() {
            const cvs = document.createElement('canvas'); cvs.width = 256; cvs.height = 256;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, 256, 256); // N·ªÅn ƒëen (trong su·ªët)
            ctx.fillStyle = '#FFF'; ctx.beginPath(); ctx.arc(128, 128, 120, 0, Math.PI * 2); ctx.fill(); // V√≤ng tr√≤n tr·∫Øng (hi·ªán ·∫£nh)
            return new THREE.CanvasTexture(cvs);
        }

        const tex = { gold: createSharpGlow('#FFFFA0','#FFD700'), red: createSharpGlow('#FF80A0','#FF0055'), snow: createSoftSnowTex(), heart: createHeartTex() };
        const circleAlpha = createCircularAlphaMap(); // T·∫°o alpha map

        let scene, camera, renderer, bgMusic = null;
        let groupGold, groupRed, groupSnow, groupRainHearts, starMesh, starGlow;
        let groupMouseTrail, mouseParticles = [];
        let photoMeshes = [], titleMesh; 
        
        let state = 'TREE'; let selectedIndex = 0; let time = 0; let lastTime = 0;
        let handRot = 0; let pendingState = 'TREE'; let holdCount = 0;
        let handsObj = null, cameraObj = null, isCameraOn = false;
        
        let mouse = new THREE.Vector2(-1000, -1000);

        function init3D() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x100520, 0.002);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000); camera.position.z = 130;
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            container.appendChild(renderer.domElement);

            createParticles(); 
            createFallingHearts(); 
            createStar3D(); 
            createPhotos(); 
            createTitle();
            createMouseTrail();
            
            document.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('resize', () => { 
                camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); 
                renderer.setSize(window.innerWidth,window.innerHeight); 
            });
            animate();
            startTyping();
        }

        function startTyping() {
            const box = document.getElementById('message-box');
            let i = 0;
            const type = () => {
                if(i < typingText.length) {
                    box.innerHTML = typingText.substring(0, i+1) + '<span id="cursor"></span>';
                    i++; setTimeout(type, 100);
                } else box.innerHTML = typingText + '<span id="cursor"></span>';
            }
            setTimeout(type, 1000);
        }

        function createMouseTrail() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(150 * 3); 
            const sizes = new Float32Array(150);
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            groupMouseTrail = new THREE.Points(geometry, new THREE.PointsMaterial({color: 0xFFFFDD, size: 2, map: tex.gold, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, depthWrite: false}));
            scene.add(groupMouseTrail);
            for(let i=0; i<50; i++) mouseParticles.push({x:0, y:0, z:0, vx:(Math.random()-0.5), vy:(Math.random()-0.5), vz:(Math.random()-0.5), life:0, maxLife:1+Math.random()});
        }

        function onMouseMove(event) {
            const vec = new THREE.Vector3(); const pos = new THREE.Vector3();
            vec.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1, 0.5);
            vec.unproject(camera); vec.sub(camera.position).normalize();
            const distance = -camera.position.z / vec.z; pos.copy(camera.position).add(vec.multiplyScalar(distance));
            mouse.x = pos.x; mouse.y = pos.y;
        }

        function createStar3D() {
            const starShape = new THREE.Shape();
            const outerRadius = 6; const innerRadius = 3; const spikes = 5;
            for(let i=0; i<spikes*2; i++){
                const r = (i%2 === 0) ? outerRadius : innerRadius;
                const a = (i / (spikes*2)) * Math.PI * 2 + Math.PI/2;
                if(i===0) starShape.moveTo(Math.cos(a)*r, Math.sin(a)*r);
                else starShape.lineTo(Math.cos(a)*r, Math.sin(a)*r);
            }
            starShape.closePath();
            const geom = new THREE.ExtrudeGeometry(starShape, { depth: 2, bevelEnabled: true, bevelThickness: 0.5, bevelSize: 0.5, bevelSegments: 2 });
            starMesh = new THREE.Mesh(geom, new THREE.MeshBasicMaterial({ color: 0xFFD700 }));
            starMesh.position.y = CONFIG.treeHeight / 2 + 2; 
            const glowMat = new THREE.MeshBasicMaterial({ color: 0xFFDD44, transparent: true, opacity: 0.3, blending: THREE.AdditiveBlending });
            starGlow = new THREE.Mesh(new THREE.ExtrudeGeometry(starShape, { depth: 2.2, bevelEnabled: true, bevelThickness: 1, bevelSize: 1 }), glowMat);
            starMesh.add(starGlow); scene.add(starMesh);
        }

        function createFallingHearts() {
            let geo = new THREE.BufferGeometry(), pos=[], vel=[], sizes=[];
            for(let i=0;i<CONFIG.heartRainCount;i++){
                pos.push((Math.random()-0.5)*500, (Math.random()-0.5)*400, (Math.random()-0.5)*400);
                vel.push(0, -0.3-Math.random()*0.4, 0); sizes.push(8 + Math.random() * 7);
            }
            geo.setAttribute('position',new THREE.Float32BufferAttribute(pos,3));
            geo.setAttribute('size',new THREE.Float32BufferAttribute(sizes,1));
            geo.userData={vel:vel};
            groupRainHearts = new THREE.Points(geo, new THREE.PointsMaterial({map:tex.heart, size:2.0, transparent:true, opacity:0.8, depthWrite:false, blending:THREE.AdditiveBlending, sizeAttenuation:true, color: 0xFF5588}));
            scene.add(groupRainHearts);
        }

        function createParticles() {
            let geo = new THREE.BufferGeometry(), pos=[], vel=[], sizes=[];
            for(let i=0;i<CONFIG.snowCount;i++){ 
                pos.push((Math.random()-0.5)*600,(Math.random()-0.5)*500,(Math.random()-0.5)*500); 
                vel.push((Math.random()-0.5)*0.5, -0.5-Math.random()*0.8, (Math.random()-0.5)*0.5); 
                sizes.push(5 + Math.random() * 7);
            }
            geo.setAttribute('position',new THREE.Float32BufferAttribute(pos,3)); 
            geo.setAttribute('size',new THREE.Float32BufferAttribute(sizes,1));
            geo.userData={vel:vel};
            groupSnow=new THREE.Points(geo,new THREE.PointsMaterial({size:1.5, map:tex.snow, transparent:true, opacity:0.8, depthWrite:false, blending:THREE.AdditiveBlending, sizeAttenuation:true}));
            scene.add(groupSnow);

            [ ['gold',CONFIG.goldCount,3.5], ['red',CONFIG.redCount,5.0] ].forEach(([type, cnt, sz]) => {
                const p=[], tr=[], ex=[], ht=[], c=[], s=[], ph=[];
                const bc = type==='gold'?new THREE.Color(0xFFF0A0):new THREE.Color(0xFF2066);
                for(let i=0; i<cnt; i++) {
                    const h = Math.random()*CONFIG.treeHeight; 
                    const y = h - CONFIG.treeHeight/2;
                    const r = (1 - Math.pow(h/CONFIG.treeHeight, 1.2)) * CONFIG.treeBaseRadius * (Math.sqrt(Math.random())); 
                    const a = Math.random()*Math.PI*2; 
                    tr.push(r*Math.cos(a), y, r*Math.sin(a));
                    
                    const ra=CONFIG.explodeRadius*Math.cbrt(Math.random()), phi=Math.acos(2*Math.random()-1), lam=Math.random()*Math.PI*2;
                    ex.push(ra*Math.sin(phi)*Math.cos(lam),ra*Math.sin(phi)*Math.sin(lam),ra*Math.cos(phi));
                    
                    const t=Math.random()*Math.PI*2, sc=2.0*Math.sqrt(Math.random());
                    ht.push(16*Math.pow(Math.sin(t),3)*sc, (13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t))*sc+5, (Math.random()-0.5)*15);

                    p.push((Math.random()-0.5)*100,(Math.random()-0.5)*100,(Math.random()-0.5)*100);
                    c.push(bc.r,bc.g,bc.b); s.push(sz*(0.5+Math.random())); ph.push(Math.random()*Math.PI*2);
                }
                const g=new THREE.BufferGeometry(); g.setAttribute('position',new THREE.Float32BufferAttribute(p,3)); g.setAttribute('color',new THREE.Float32BufferAttribute(c,3)); g.setAttribute('size',new THREE.Float32BufferAttribute(s,1));
                g.userData = {tree:tr, explode:ex, heart:ht, phase:ph, baseSize:sz};
                const mat = new THREE.PointsMaterial({size:sz, map:tex[type], vertexColors:true, blending:THREE.AdditiveBlending, depthWrite:false, transparent:true, opacity:1.0, sizeAttenuation:true});
                const mesh = new THREE.Points(g, mat);
                if(type==='gold') groupGold=mesh; else groupRed=mesh; scene.add(mesh);
            });
        }

        function createTitle() {
            const cvs = document.createElement('canvas'); cvs.width=512; cvs.height=128; const ctx=cvs.getContext('2d');
            ctx.font="bold 70px 'Pacifico'"; ctx.fillStyle="#FFD700"; ctx.textAlign="center"; 
            ctx.shadowColor="#FF4500"; ctx.shadowBlur=30; 
            ctx.fillText("Merry Christmas",256,90);
            titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(55,14), new THREE.MeshBasicMaterial({map:new THREE.CanvasTexture(cvs), transparent:true, blending: THREE.AdditiveBlending}));
            titleMesh.position.set(0,65,0); scene.add(titleMesh);
        }

        // --- UPDATED: CIRCULAR FRAME PARTICLES ---
        function addFrameParticlesCircular(mesh) {
            const geometry = new THREE.BufferGeometry();
            const count = 60;
            const positions = [];
            const radius = 6.25; // B√°n k√≠nh vi·ªÅn

            for(let i=0; i<count; i++) {
                const angle = (i / count) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                positions.push(x, y, 0.1);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                size: 0.8, color: 0xFFFF00, map: tex.gold,
                transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending
            });
            const points = new THREE.Points(geometry, material);
            mesh.add(points);
            mesh.userData.sparkles = points;
        }

        function createPhotos() {
            photoFiles.forEach(u=>photoTextures.push(loader.load(u)));
            for(let i=0;i<5;i++){
                // S·ª≠ d·ª•ng Alpha Map ƒë·ªÉ l√†m ·∫£nh tr√≤n
                const m = new THREE.Mesh(
                    new THREE.PlaneGeometry(12, 12),
                    new THREE.MeshBasicMaterial({
                        map: photoTextures[i], side: THREE.DoubleSide, transparent: true,
                        alphaMap: circleAlpha // √Åp d·ª•ng m·∫∑t n·∫° tr√≤n
                    })
                );
                
                // Vi·ªÅn tr√≤n
                const border = new THREE.Mesh(
                    new THREE.PlaneGeometry(12.5, 12.5),
                    new THREE.MeshBasicMaterial({
                        color: 0xFFD700, transparent: true, opacity: 0.5, blending:THREE.AdditiveBlending,
                        alphaMap: circleAlpha // √Åp d·ª•ng m·∫∑t n·∫° tr√≤n cho vi·ªÅn
                    })
                );
                border.position.z = -0.1; m.add(border);

                // H·∫°t b√°m khung tr√≤n
                addFrameParticlesCircular(m);

                m.visible=false; scene.add(m); photoMeshes.push(m);
            }
        }

        function animate(now=0) {
            requestAnimationFrame(animate);
            const dt = Math.min((now-lastTime)/1000, 0.05); lastTime=now; time+=dt;
            
            updateFalling(groupSnow, dt, true);
            updateFalling(groupRainHearts, dt, false);

            if(groupMouseTrail) {
                const pos = groupMouseTrail.geometry.attributes.position.array;
                const sz = groupMouseTrail.geometry.attributes.size.array;
                for(let i=0; i<mouseParticles.length; i++) {
                    const p = mouseParticles[i]; p.life -= dt * 2;
                    if(p.life <= 0 && mouse.x > -900) { p.life = p.maxLife; p.x = mouse.x + (Math.random()-0.5)*2; p.y = mouse.y + (Math.random()-0.5)*2; p.z = 0; }
                    p.x += p.vx; p.y += p.vy;
                    pos[i*3] = p.x; pos[i*3+1] = p.y; pos[i*3+2] = p.z; sz[i] = Math.max(0, p.life * 4);
                }
                groupMouseTrail.geometry.attributes.position.needsUpdate = true; groupMouseTrail.geometry.attributes.size.needsUpdate = true;
            }

            [groupGold, groupRed].forEach(g => {
                if(!g) return;
                const p=g.geometry.attributes.position.array, sz=g.geometry.attributes.size.array, ud=g.geometry.userData;
                
                let tgt;
                if (state === 'EXPLODE' || state === 'PHOTO') tgt = ud.explode;
                else if (state === 'HEART') tgt = ud.heart;
                else tgt = ud.tree;

                const spd = (state==='EXPLODE' || state === 'PHOTO') ? 4.0 : 2.5;
                
                for(let i=0; i<p.length; i++) {
                    p[i] += (tgt[i]-p[i])*spd*dt;
                    if(state==='EXPLODE' || state === 'PHOTO') sz[i] = ud.baseSize * (0.8 + 0.5 * Math.sin(time * 15 + i));
                    else sz[i] = ud.baseSize * (0.9 + 0.2*Math.sin(time*2 + i));
                }
                
                if(state === 'EXPLODE') {
                    g.rotation.y += (handRot - g.rotation.y)*3*dt;
                } else if (state === 'PHOTO') {
                    g.rotation.y += 0.15 * dt; 
                } else {
                    g.rotation.y += 0.2*dt;
                }

                g.geometry.attributes.position.needsUpdate=true; g.geometry.attributes.size.needsUpdate=true;
            });

            if(starMesh) {
                starMesh.visible = (state === 'TREE');
                if(starMesh.visible) {
                    starMesh.rotation.y += 1.5 * dt; starMesh.rotation.z = Math.sin(time)*0.1;
                    starGlow.material.opacity = 0.3 + 0.1 * Math.sin(time*3);
                }
            }

            titleMesh.visible = (state==='TREE'); titleMesh.position.y = 75 + Math.sin(time*1.5)*3; 
            
            photoMeshes.forEach((m,i)=>{
                m.visible = (state!=='TREE' && state!=='HEART');
                if(m.visible) {
                    if(m.userData.sparkles) {
                        m.userData.sparkles.material.opacity = 0.5 + 0.5 * Math.sin(time * 5 + i);
                        m.userData.sparkles.rotation.z -= dt * 0.5;
                    }

                    if(state==='PHOTO' && i===selectedIndex) { 
                        m.position.lerp(new THREE.Vector3(0,0,70), 0.08); 
                        m.scale.lerp(new THREE.Vector3(3.5,3.5,3.5), 0.08); 
                    } else { 
                        const angle = (i / photoMeshes.length) * Math.PI * 2 + time * 0.3; 
                        const radiusX = 50; const radiusZ = 50;
                        const targetY = Math.sin(angle * 2 + i) * 15 + Math.sin(time + i)*5; 
                        m.position.lerp(new THREE.Vector3(Math.cos(angle) * radiusX, targetY, Math.sin(angle) * radiusZ), 0.05);
                        m.scale.lerp(new THREE.Vector3(1,1,1), 0.1); 
                    }
                    m.lookAt(camera.position);
                }
            });
            renderer.render(scene, camera);
        }

        function updateFalling(group, dt, isSnow) {
            if(!group) return;
            const pos=group.geometry.attributes.position.array, vel=group.geometry.userData.vel;
            const range = isSnow ? 600 : 500;
            const windX = (mouse.x > -900) ? (mouse.x / window.innerWidth) * 5 : 0;

            for(let i=0;i<pos.length;i+=3){ 
                pos[i] += (vel[i/3] + Math.sin(time + pos[i+1]*0.01)*0.5 + windX) * dt * 10; 
                pos[i+2] += (vel[i/3+2] + Math.cos(time + pos[i+1]*0.01)*0.5) * dt * 10;
                pos[i+1] += vel[i/3+1]*35*dt; 
                if(pos[i+1]<-250) { pos[i+1]=300; pos[i]=(Math.random()-0.5)*range; pos[i+2]=(Math.random()-0.5)*range; }
            }
            group.geometry.attributes.position.needsUpdate=true;
        }

        document.getElementById('btnStart').onclick = async () => {
            document.getElementById('ui-layer').style.pointerEvents = 'none';
            document.getElementById('btnStart').style.opacity = '0';
            document.getElementById('loading').style.display='block';
            try { bgMusic = new Audio(MUSIC_URL); bgMusic.loop=true; bgMusic.volume=0.8; await bgMusic.play(); } catch(e){}
            init3D(); startCamera();
        };

        async function startCamera() {
            handsObj = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            handsObj.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7});
            handsObj.onResults(res => {
                const cvs = document.getElementById('camera-preview'); const ctx = cvs.getContext('2d');
                cvs.width = 160; cvs.height = 120; ctx.clearRect(0,0,160,120); 
                ctx.filter = 'brightness(1.2)'; ctx.drawImage(res.image,0,0,160,120); ctx.filter = 'none';
                if(res.multiHandLandmarks.length) processGestures(res.multiHandLandmarks[0]);
                document.getElementById('loading').style.display='none';
                document.getElementById('btnCamToggle').style.display='block';
                document.getElementById('btnStart').style.display='none';
            });
            const vid = document.querySelector('.input_video');
            cameraObj = new Camera(vid, { onFrame: async()=>{ await handsObj.send({image:vid}); }, width: 320, height: 240 });
            await cameraObj.start();
        }

        function processGestures(lm) {
            const isOpen = (i) => lm[i].y < lm[i-2].y;
            const count = [8,12,16,20].filter(i => isOpen(i)).length;
            const isThumbHeart = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y) < 0.04 && !isOpen(12);
            let det = 'TREE';
            if(isThumbHeart) det = 'HEART';
            else if(count >= 4) { det = 'EXPLODE'; handRot = (0.5-lm[9].x)*6; }
            else if(count === 2 && isOpen(8) && isOpen(12)) { det = 'PHOTO'; selectedIndex = Math.floor((1-lm[8].x)*5.9)%5; }
            if(det === pendingState) { holdCount++; if(holdCount > 6) state = det; }
            else { pendingState = det; holdCount = 0; }
        }
        document.getElementById('btnCamToggle').onclick = () => {
            const wrap = document.getElementById('camera-wrapper');
            wrap.style.opacity = wrap.style.opacity === '0' ? '1' : '0';
        }
    </script>
</body>
</html>
